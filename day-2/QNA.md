# üß† AIDD 30-Day Challenge ‚Äî Task 2 AI-Driven Development (ADD)

---

## üë§ Name: Mohummad Anees (CO-ordinator)

## üéì Roll Number: [00231706]

---

# Part A - ‚Äî Theory (Short Questions)

## section 1. Nine Pillars Understanding

### **a) Why is using AI Development Agents for repetitive setup tasks better for your growth as a system architect?**


When I look back at my own journey‚Äîfrom struggling in Turbo C++, searching YouTube for every small C error, spending hours fixing Arduino code, and even taking 30‚Äì60 minutes just to set up a simple MERN folder structure‚ÄîI realize how much time I used to waste on basic, repetitive setups. Tools like Gemini CLI now handle those things in seconds. This actually helps me grow as a system architect because instead of getting stuck in the same boilerplate tasks, I can focus on planning the system, designing the architecture, and thinking about how different parts of the project connect. The agent does the boring work, and I get to practice the higher-level decisions that truly matter in building real software.



### **b) How do the Nine Pillars help a developer grow into an M-Shaped Developer?**

For me, the Nine Pillars act like a complete learning roadmap. When I started coding back in 2022, I was only focused on one skill at a time‚Äîfirst C language, then Arduino, then frontend, then MERN, then microservices , aws , docker , openai agnet sdk , fastapi , postgreesql db and later tools like Gemini CLI and Speckit Plus. But the Nine Pillars combine all these areas together: testing, specs, AI agents, architecture thinking, evaluation, and automation. Because of this, a developer doesn‚Äôt stay limited to just ‚Äúcoding.‚Äù You naturally start learning multiple deep skills at the same time‚Äîhow to design systems, how to write clear specifications, how to use agents, how to test, how to plan, and how to evaluate outputs. This mix of depth in different areas is exactly what makes someone an **M-Shaped developer**. Instead of being strong in only one field, you grow into someone who can understand architecture, write specs, collaborate with AI, and still code when needed.

**But here‚Äôs the turning point**: I actually already knew most of these things, but I never implemented them in my daily work. That‚Äôs why even though I had the potential to be an M-Shaped developer, I wasn‚Äôt growing as a system architect. Now that I‚Äôm finally applying these principles in real projects, I can feel myself improving‚Äîthinking more like a designer and architect rather than just a coder.


## section 2. Vibe Coding vs Specification-Driven Development

### **a) Why does Vibe Coding create problems after one week?**

Vibe coding dies after a week because you're running only on motivation, not a proper system.
I‚Äôve seen this myself ‚Äî last year I used Augie and it wrote 12,000+ lines of code for my Facebook clone in 3 hours, but after a week I still got stuck because I had no structure.
Without a real process, the vibe disappears and your progress collapses.


### **b) How does Specification-Driven Development prevent those problems?**


Specification-Driven Development fixes those problems because everything is broken into a clear step-by-step flow: first the Constitution, then the Specification, then the Plan, and finally proper Tasks with checkmarks. SpeckitPlus keeps it all structured and clean ‚Äî and the prompt-history record is honestly my favourite part because I never lose context. With this system, I don‚Äôt rely on vibes anymore, and I can stay consistent even when motivation drops.

## section 3. Architecture Thinking

### **a) How does architecture-first thinking change the role of a developer in AIDD?**


Architecture-first thinking changes everything because you stop acting like a normal coder and start thinking like a system architect. Instead of jumping into random code, you design the flow, the constraints, the boundaries, and the responsibilities first. In AIDD, this mindset makes you the person who guides the AI instead of letting the AI guide you ‚Äî you stay in control, and the whole project becomes more predictable, scalable, and clean.

### **b) Why must developers think in layers and systems instead of raw code?**

Developers must think in layers and systems because it keeps the project organized and easy to scale. If you focus only on raw code, everything becomes messy and hard to extend. By separating responsibilities into layers, each part is clear, maintainable, and works well with the rest of the system.







